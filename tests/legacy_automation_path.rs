#![allow(clippy::disallowed_methods)]

#[cfg(unix)]
mod unix {
    use std::env;
    use std::fs::{self, File};
    use std::io::{self, Write};
    use std::os::unix::fs::PermissionsExt;
    use std::path::{Path, PathBuf};
    use std::process;
    use std::process::Command;
    use std::time::{SystemTime, UNIX_EPOCH};

    struct TempDir {
        path: PathBuf,
    }

    impl TempDir {
        fn new() -> io::Result<Self> {
            let unique = format!(
                "feff85exafs-rs-legacy-automation-{}-{}",
                process::id(),
                SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .expect("system time before unix epoch")
                    .as_nanos()
            );
            let path = env::temp_dir().join(unique);
            fs::create_dir_all(&path)?;
            Ok(Self { path })
        }
    }

    impl Drop for TempDir {
        fn drop(&mut self) {
            let _ = fs::remove_dir_all(&self.path);
        }
    }

    fn copy_with_exec_permissions(source: &Path, destination: &Path) -> io::Result<()> {
        fs::copy(source, destination)?;
        let mut permissions = fs::metadata(destination)?.permissions();
        permissions.set_mode(0o755);
        fs::set_permissions(destination, permissions)?;
        Ok(())
    }

    fn write_executable(path: &Path, content: &str) -> io::Result<()> {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }
        let mut file = File::create(path)?;
        file.write_all(content.as_bytes())?;

        let mut permissions = fs::metadata(path)?.permissions();
        permissions.set_mode(0o755);
        fs::set_permissions(path, permissions)?;
        Ok(())
    }

    #[test]
    fn legacy_f85e_automation_path_runs_unchanged() {
        let tmp = TempDir::new().expect("create temporary directory");

        let legacy_tree = tmp.path.join("legacy-tree");
        let bin_dir = legacy_tree.join("bin");
        let src_dir = legacy_tree.join("src");
        fs::create_dir_all(&bin_dir).expect("create bin directory");
        fs::create_dir_all(&src_dir).expect("create src directory");

        copy_with_exec_permissions(Path::new("feff85exafs/bin/f85e"), &bin_dir.join("f85e"))
            .expect("copy f85e automation script");

        let modules = [
            ("RDINP", "rdinp", "rdinp", Some("files.dat")),
            ("POT", "pot", "pot", None),
            ("XSPH", "xsph", "xsph", None),
            ("PATH", "pathfinder", "pathfinder", Some("paths.dat")),
            ("GENFMT", "genfmt", "genfmt", None),
            ("FF2X", "ff2x", "ff2x", Some("xmu.dat chi.dat feff0001.dat")),
        ];

        for (folder, executable, stage_name, outputs) in modules {
            let script_body = if let Some(outputs) = outputs {
                format!("#!/bin/sh\necho \"{stage_name}\" >> stage-order.log\ntouch {outputs}\n")
            } else {
                format!("#!/bin/sh\necho \"{stage_name}\" >> stage-order.log\n")
            };
            write_executable(&src_dir.join(folder).join(executable), script_body.as_str())
                .expect("write fake legacy module executable");
        }

        let run_dir = tmp.path.join("run");
        fs::create_dir_all(&run_dir).expect("create run directory");
        fs::write(run_dir.join("feff.inp"), "TITLE fake input\n")
            .expect("write placeholder feff input");

        let output = Command::new(bin_dir.join("f85e"))
            .current_dir(&run_dir)
            .output()
            .expect("run unchanged f85e automation path");
        assert!(
            output.status.success(),
            "f85e script failed.\nstdout:\n{}\nstderr:\n{}",
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );

        let stage_order = fs::read_to_string(run_dir.join("stage-order.log"))
            .expect("read stage-order log generated by fake modules");
        let observed = stage_order
            .lines()
            .map(str::trim)
            .filter(|line| !line.is_empty())
            .collect::<Vec<_>>();
        assert_eq!(
            observed,
            vec!["rdinp", "pot", "xsph", "pathfinder", "genfmt", "ff2x"]
        );

        let legacy_log =
            fs::read_to_string(run_dir.join("f85e.log")).expect("read legacy automation log");
        assert!(legacy_log.contains("running module rdinp"));
        assert!(legacy_log.contains("running module pathfinder"));
    }
}

#[cfg(not(unix))]
#[test]
fn legacy_f85e_automation_path_runs_unchanged() {
    eprintln!("skipped: legacy automation integration test requires unix shell scripts");
}
