#![allow(clippy::disallowed_methods)]

#[cfg(unix)]
mod unix {
    use std::env;
    use std::fs::{self, File};
    use std::io::{self, Write};
    use std::os::unix::fs::PermissionsExt;
    use std::path::{Path, PathBuf};
    use std::process;
    use std::process::{Command, Output};
    use std::time::{SystemTime, UNIX_EPOCH};

    struct TempDir {
        path: PathBuf,
    }

    impl TempDir {
        fn new() -> io::Result<Self> {
            let unique = format!(
                "feff85exafs-rs-legacy-automation-{}-{}",
                process::id(),
                SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .expect("system time before unix epoch")
                    .as_nanos()
            );
            let path = env::temp_dir().join(unique);
            fs::create_dir_all(&path)?;
            Ok(Self { path })
        }
    }

    impl Drop for TempDir {
        fn drop(&mut self) {
            let _ = fs::remove_dir_all(&self.path);
        }
    }

    fn copy_with_exec_permissions(source: &Path, destination: &Path) -> io::Result<()> {
        fs::copy(source, destination)?;
        let mut permissions = fs::metadata(destination)?.permissions();
        permissions.set_mode(0o755);
        fs::set_permissions(destination, permissions)?;
        Ok(())
    }

    fn write_executable(path: &Path, content: &str) -> io::Result<()> {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }
        let mut file = File::create(path)?;
        file.write_all(content.as_bytes())?;

        let mut permissions = fs::metadata(path)?.permissions();
        permissions.set_mode(0o755);
        fs::set_permissions(path, permissions)?;
        Ok(())
    }

    struct LegacyRunContext {
        _tmp: TempDir,
        run_dir: PathBuf,
        output: Output,
    }

    const EXPECTED_STAGE_ORDER: [&str; 6] =
        ["rdinp", "pot", "xsph", "pathfinder", "genfmt", "ff2x"];

    fn run_f85e_with_fixture(
        fixture_relative_path: &str,
        create_stale_log: bool,
    ) -> io::Result<LegacyRunContext> {
        let tmp = TempDir::new()?;

        let legacy_tree = tmp.path.join("legacy-tree");
        let bin_dir = legacy_tree.join("bin");
        let src_dir = legacy_tree.join("src");
        fs::create_dir_all(&bin_dir)?;
        fs::create_dir_all(&src_dir)?;

        copy_with_exec_permissions(Path::new("feff85exafs/bin/f85e"), &bin_dir.join("f85e"))?;

        let modules = [
            ("RDINP", "rdinp", "rdinp", Some("files.dat")),
            ("POT", "pot", "pot", None),
            ("XSPH", "xsph", "xsph", None),
            ("PATH", "pathfinder", "pathfinder", Some("paths.dat")),
            ("GENFMT", "genfmt", "genfmt", None),
            ("FF2X", "ff2x", "ff2x", Some("xmu.dat chi.dat feff0001.dat")),
        ];

        for (folder, executable, stage_name, outputs) in modules {
            let script_body = if let Some(outputs) = outputs {
                format!("#!/bin/sh\necho \"{stage_name}\" >> stage-order.log\ntouch {outputs}\n")
            } else {
                format!("#!/bin/sh\necho \"{stage_name}\" >> stage-order.log\n")
            };
            write_executable(&src_dir.join(folder).join(executable), script_body.as_str())?;
        }

        let run_dir = tmp.path.join("run");
        fs::create_dir_all(&run_dir)?;

        let fixture_input =
            fs::read_to_string(Path::new("feff85exafs/tests").join(fixture_relative_path))?;
        fs::write(run_dir.join("feff.inp"), fixture_input)?;

        if create_stale_log {
            fs::write(run_dir.join("log123.dat"), "stale log")?;
        }

        let output = Command::new(bin_dir.join("f85e"))
            .current_dir(&run_dir)
            .output()?;

        Ok(LegacyRunContext {
            _tmp: tmp,
            run_dir,
            output,
        })
    }

    fn read_stage_order(run_dir: &Path) -> Vec<String> {
        fs::read_to_string(run_dir.join("stage-order.log"))
            .expect("read stage-order log generated by fake modules")
            .lines()
            .map(str::trim)
            .filter(|line| !line.is_empty())
            .map(ToOwned::to_owned)
            .collect::<Vec<_>>()
    }

    fn assert_successful_legacy_run(context: &LegacyRunContext) {
        assert!(
            context.output.status.success(),
            "f85e script failed.\nstdout:\n{}\nstderr:\n{}",
            String::from_utf8_lossy(&context.output.stdout),
            String::from_utf8_lossy(&context.output.stderr)
        );

        assert_eq!(
            read_stage_order(&context.run_dir),
            EXPECTED_STAGE_ORDER
                .iter()
                .map(|value| value.to_string())
                .collect::<Vec<_>>()
        );

        let legacy_log =
            fs::read_to_string(context.run_dir.join("f85e.log")).expect("read f85e.log output");
        assert!(legacy_log.contains("running module rdinp"));
        assert!(legacy_log.contains("running module pathfinder"));
        assert!(legacy_log.contains("running module ff2x"));

        for required_output in [
            "files.dat",
            "paths.dat",
            "xmu.dat",
            "chi.dat",
            "feff0001.dat",
        ] {
            assert!(
                context.run_dir.join(required_output).is_file(),
                "expected output {required_output} was not generated"
            );
        }
    }

    #[test]
    fn legacy_f85e_automation_path_runs_unchanged_for_noscf_fixture() {
        let context = run_f85e_with_fixture("Copper/baseline/noSCF/feff.inp", true)
            .expect("run legacy noSCF workflow");
        assert_successful_legacy_run(&context);
        assert!(
            !context.run_dir.join("log123.dat").exists(),
            "legacy cleanup should remove log*.dat artifacts"
        );
    }

    #[test]
    fn legacy_f85e_automation_path_runs_unchanged_for_withscf_fixture() {
        let context = run_f85e_with_fixture("Copper/baseline/withSCF/feff.inp", false)
            .expect("run legacy withSCF workflow");
        assert_successful_legacy_run(&context);
    }
}

#[cfg(not(unix))]
#[test]
fn legacy_f85e_automation_path_runs_unchanged_for_noscf_fixture() {
    eprintln!("skipped: legacy automation integration tests require unix shell scripts");
}

#[cfg(not(unix))]
#[test]
fn legacy_f85e_automation_path_runs_unchanged_for_withscf_fixture() {
    eprintln!("skipped: legacy automation integration tests require unix shell scripts");
}
