# Ralph Progress Log
## Codebase Patterns
- Use `feff85exafs/src/*/Makefile` and `feff85exafs/src/*/SConstruct` as the canonical source for module dependency mapping; `README` files are descriptive but less precise for direct build deps.
- The core execution chain for this project is fixed as `rdinp -> pot -> xsph -> pathfinder -> genfmt -> ff2x`; treat other modules as supporting or non-core unless a story explicitly expands scope.
- Phase scope docs in `docs/migration/` should define release readiness with paired gates per workflow: feature parity gates and test parity gates.
- The baseline corpus runner should source data from `feff85exafs/tests/*/baseline/noSCF` and emit versioned manifests under `docs/migration/baselines/noSCF/<version>/` with deterministic `NNN-<slug>-noscf.json` naming plus `index.json`.
- Keep baseline material coverage synchronized between `noSCF` and `withSCF`; SCF corpus generation should fail fast if either variant is missing materials so parity checks stay aligned.
- Rust code now uses a Cargo workspace with the CLI at repo root and shared crates under `crates/`; run quality gates with `cargo fmt --all`, `cargo check --workspace`, and `cargo test --workspace`.
- Shared Rust domain models should live in `crates/feff85exafs-core/src/domain.rs` and expose `validate()` methods that collect field issues in `ValidationErrors` and return `FeffError::Validation` for consistent API error handling.

Started: Mon Feb 16 03:58:44 JST 2026
---
## 2026-02-16 04:00:57 JST - US-001
- Created `docs/migration/module-map.md` with a full legacy module inventory and direct dependency map, including the required core stage order.
- Files changed: `docs/migration/module-map.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Dependency truth for legacy modules lives in both Makefile and SConstruct files under `feff85exafs/src/`; use both when planning migration steps.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - Ralph tracking artifacts are under `scripts/ralph/` in this repository, not the repo root.
  - Useful context (e.g., "the evaluation panel is in component X")
    - `POT` and `XSPH` have the widest direct dependency surface among core stages and are likely to be the highest-risk integration boundaries during Rust porting.
---
## 2026-02-16 04:09:24 JST - US-002
- Created `docs/migration/phase1-scope.md` defining Phase 1 core/supporting/non-core module scope and explicit release gates.
- Files changed: `docs/migration/phase1-scope.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Migration planning docs in this repo should pair workflow-level feature parity criteria with workflow-level test parity criteria so release gates are objective.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - Keep module classification aligned with `docs/migration/module-map.md`; `EXCH`/`FOVRG` are supporting dependencies for core execution but full standalone ports remain non-core until later stories.
  - Useful context (e.g., "the evaluation panel is in component X")
    - The strictest Phase 1 completion signal is end-to-end parity for both noSCF and SCF variants of the core chain, not just stage-level success.
---
## 2026-02-16 04:14:51 JST - US-003
- Implemented a Rust noSCF baseline corpus runner (`cargo run -- baseline noscf`) that discovers material baselines in `feff85exafs/tests`, computes per-file SHA-256 digests, and writes deterministic per-material manifests plus an index.
- Stored versioned noSCF corpus artifacts under `docs/migration/baselines/noSCF/v1/` with deterministic `NNN-<material>-noscf.json` names.
- Files changed: `Cargo.toml`, `Cargo.lock`, `src/lib.rs`, `src/baseline.rs`, `src/main.rs`, `docs/migration/noscf-baseline-corpus.md`, `docs/migration/baselines/noSCF/v1/index.json`, `docs/migration/baselines/noSCF/v1/001-bromoadamantane-noscf.json`, `docs/migration/baselines/noSCF/v1/002-copper-noscf.json`, `docs/migration/baselines/noSCF/v1/003-ferrocene-noscf.json`, `docs/migration/baselines/noSCF/v1/004-lco-para-noscf.json`, `docs/migration/baselines/noSCF/v1/005-lco-perp-noscf.json`, `docs/migration/baselines/noSCF/v1/006-nio-noscf.json`, `docs/migration/baselines/noSCF/v1/007-uo2-noscf.json`, `docs/migration/baselines/noSCF/v1/008-zircon-noscf.json`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Corpus generation for migration artifacts is stable when material folders are lexicographically sorted and manifests avoid runtime-specific values (timestamps/random IDs).
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - `cargo fmt --check` should be run before `cargo check/test` in this repo, since small CLI formatting issues are easy to miss and block quality gates.
- Useful context (e.g., "the evaluation panel is in component X")
    - The legacy test corpus currently yields 8 noSCF material cases (`bromoadamantane`, `Copper`, `ferrocene`, `LCO-para`, `LCO-perp`, `NiO`, `UO2`, `Zircon`) for baseline manifest generation.
---
## 2026-02-16 04:19:55 JST - US-004
- Extended the Rust baseline corpus runner to support SCF generation via `cargo run -- baseline scf` (also `withscf` aliases), while keeping deterministic ordering, hashing, and manifest naming.
- Generated versioned SCF artifacts under `docs/migration/baselines/withSCF/v1/` for the same 8 reference materials used by noSCF baselines.
- Added SCF regeneration documentation with command usage and environment prerequisites in `docs/migration/scf-baseline-corpus.md`.
- Files changed: `src/baseline.rs`, `src/main.rs`, `docs/migration/scf-baseline-corpus.md`, `docs/migration/baselines/withSCF/v1/index.json`, `docs/migration/baselines/withSCF/v1/001-bromoadamantane-withscf.json`, `docs/migration/baselines/withSCF/v1/002-copper-withscf.json`, `docs/migration/baselines/withSCF/v1/003-ferrocene-withscf.json`, `docs/migration/baselines/withSCF/v1/004-lco-para-withscf.json`, `docs/migration/baselines/withSCF/v1/005-lco-perp-withscf.json`, `docs/migration/baselines/withSCF/v1/006-nio-withscf.json`, `docs/migration/baselines/withSCF/v1/007-uo2-withscf.json`, `docs/migration/baselines/withSCF/v1/008-zircon-withscf.json`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Baseline generation logic is easiest to keep consistent by routing both noSCF/withSCF through the same manifest pipeline and only varying the variant metadata/path suffixes.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - SCF corpus generation should validate material-set parity with noSCF before writing artifacts, otherwise index-level parity gates can silently drift.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Current corpus coverage is symmetric at 8 materials for both noSCF and withSCF, and SCF manifests are emitted as `NNN-<slug>-withscf.json`.
---
## 2026-02-16 04:23:26 JST - US-005
- Scaffolded a Cargo workspace by adding `crates/feff85exafs-core` and `crates/feff85exafs-errors`, and wiring the root crate as the CLI package that depends on both workspace crates.
- Moved baseline generation engine code into `feff85exafs-core` and introduced a shared `FeffError` type in `feff85exafs-errors` used by both core APIs and CLI argument handling.
- Files changed: `Cargo.toml`, `Cargo.lock`, `src/main.rs`, `src/lib.rs` (deleted), `src/baseline.rs` (moved to core crate), `crates/feff85exafs-core/Cargo.toml`, `crates/feff85exafs-core/src/lib.rs`, `crates/feff85exafs-core/src/baseline.rs`, `crates/feff85exafs-errors/Cargo.toml`, `crates/feff85exafs-errors/src/lib.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Keep CLI-focused UX (argument parsing/output) in the root crate and put reusable execution logic into `crates/feff85exafs-core` so later API stories can build on the same core code.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - When switching a module from `io::Result` to shared error types, explicit `Err(io::Error::other(...).into())` conversions are required in branches that construct errors directly.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Existing `cargo run -- baseline ...` commands continue to work because the root package remains a concrete crate even after enabling workspace members.
---
## 2026-02-16 04:27:21 JST - US-006
- Implemented shared domain model types in `feff85exafs-core`: `RunConfig`, `ParsedInputCards`, and `OutputMetadata` with supporting enums/structs.
- Added serde serialization/deserialization derives and explicit `validate()` methods for each domain model.
- Extended `feff85exafs-errors` with `ValidationIssue`, `ValidationErrors`, and `FeffError::Validation` to report structured validation failures.
- Added unit tests for validation success/failure scenarios and serde round-trips for all shared domain types.
- Files changed: `crates/feff85exafs-core/src/lib.rs`, `crates/feff85exafs-core/src/domain.rs`, `crates/feff85exafs-errors/src/lib.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Use `ValidationErrors` as an accumulator and return a single `FeffError::Validation` from `validate()` so callers get all field failures in one pass.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - `OutputMetadata` validation should enforce unique `PipelineStage` entries; otherwise repeated stage metadata can silently hide orchestration issues.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Domain enums (`RunMode`, `ScfStrategy`, `PipelineStage`) are serde-ready and intended to be reused by upcoming CLI/API mode-selection and orchestration stories.
---
