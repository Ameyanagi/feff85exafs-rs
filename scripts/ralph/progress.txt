# Ralph Progress Log
## Codebase Patterns
- Use `feff85exafs/src/*/Makefile` and `feff85exafs/src/*/SConstruct` as the canonical source for module dependency mapping; `README` files are descriptive but less precise for direct build deps.
- The core execution chain for this project is fixed as `rdinp -> pot -> xsph -> pathfinder -> genfmt -> ff2x`; treat other modules as supporting or non-core unless a story explicitly expands scope.
- Phase scope docs in `docs/migration/` should define release readiness with paired gates per workflow: feature parity gates and test parity gates.
- The baseline corpus runner should source data from `feff85exafs/tests/*/baseline/noSCF` and emit versioned manifests under `docs/migration/baselines/noSCF/<version>/` with deterministic `NNN-<slug>-noscf.json` naming plus `index.json`.
- Keep baseline material coverage synchronized between `noSCF` and `withSCF`; SCF corpus generation should fail fast if either variant is missing materials so parity checks stay aligned.
- Rust code now uses a Cargo workspace with the CLI at repo root and shared crates under `crates/`; run quality gates with `cargo fmt --all`, `cargo check --workspace`, and `cargo test --workspace`.
- Shared Rust domain models should live in `crates/feff85exafs-core/src/domain.rs` and expose `validate()` methods that collect field issues in `ValidationErrors` and return `FeffError::Validation` for consistent API error handling.
- For CLI/API mode flags, centralize parsing in `crates/feff85exafs-core/src/mode.rs` and return field-specific `FeffError::Validation` issues instead of free-form argument errors.
- Keep legacy-compatibility orchestration rules in `crates/feff85exafs-core/src/legacy.rs`; legacy baseline validation should require canonical legacy outputs (`feff.inp`, `files.dat`, `paths.dat`, `xmu.dat`, `chi.dat`, `f85e.log`, and at least one `feffNNNN.dat`).
- Keep typed execution entrypoints in `crates/feff85exafs-core/src/api.rs` and make `src/main.rs` a thin argument-to-request adapter so CLI and library behavior stay in sync.
- For modern API config handling, keep request execution in `api::run(RunRequest)` and route alternate config sources through `api::run_with_config(...)` / `api::run_from_file(...)` to avoid duplicating operation logic.
- RDINP parser validation should use the corpus fixtures at `feff85exafs/tests/*/baseline/{noSCF,withSCF}/feff.inp`, and workspace-crate tests should resolve those fixtures via `env!("CARGO_MANIFEST_DIR")`.
- RDINP parity tests should compare parsed card streams against a legacy-style token stream derived from baseline `feff.inp` fixtures, enforcing exact card order/count with numeric tolerance (`1e-9` scaled) and case-insensitive text matching.

Started: Mon Feb 16 03:58:44 JST 2026
---
## 2026-02-16 04:00:57 JST - US-001
- Created `docs/migration/module-map.md` with a full legacy module inventory and direct dependency map, including the required core stage order.
- Files changed: `docs/migration/module-map.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Dependency truth for legacy modules lives in both Makefile and SConstruct files under `feff85exafs/src/`; use both when planning migration steps.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - Ralph tracking artifacts are under `scripts/ralph/` in this repository, not the repo root.
  - Useful context (e.g., "the evaluation panel is in component X")
    - `POT` and `XSPH` have the widest direct dependency surface among core stages and are likely to be the highest-risk integration boundaries during Rust porting.
---
## 2026-02-16 04:09:24 JST - US-002
- Created `docs/migration/phase1-scope.md` defining Phase 1 core/supporting/non-core module scope and explicit release gates.
- Files changed: `docs/migration/phase1-scope.md`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Migration planning docs in this repo should pair workflow-level feature parity criteria with workflow-level test parity criteria so release gates are objective.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - Keep module classification aligned with `docs/migration/module-map.md`; `EXCH`/`FOVRG` are supporting dependencies for core execution but full standalone ports remain non-core until later stories.
  - Useful context (e.g., "the evaluation panel is in component X")
    - The strictest Phase 1 completion signal is end-to-end parity for both noSCF and SCF variants of the core chain, not just stage-level success.
---
## 2026-02-16 04:14:51 JST - US-003
- Implemented a Rust noSCF baseline corpus runner (`cargo run -- baseline noscf`) that discovers material baselines in `feff85exafs/tests`, computes per-file SHA-256 digests, and writes deterministic per-material manifests plus an index.
- Stored versioned noSCF corpus artifacts under `docs/migration/baselines/noSCF/v1/` with deterministic `NNN-<material>-noscf.json` names.
- Files changed: `Cargo.toml`, `Cargo.lock`, `src/lib.rs`, `src/baseline.rs`, `src/main.rs`, `docs/migration/noscf-baseline-corpus.md`, `docs/migration/baselines/noSCF/v1/index.json`, `docs/migration/baselines/noSCF/v1/001-bromoadamantane-noscf.json`, `docs/migration/baselines/noSCF/v1/002-copper-noscf.json`, `docs/migration/baselines/noSCF/v1/003-ferrocene-noscf.json`, `docs/migration/baselines/noSCF/v1/004-lco-para-noscf.json`, `docs/migration/baselines/noSCF/v1/005-lco-perp-noscf.json`, `docs/migration/baselines/noSCF/v1/006-nio-noscf.json`, `docs/migration/baselines/noSCF/v1/007-uo2-noscf.json`, `docs/migration/baselines/noSCF/v1/008-zircon-noscf.json`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Corpus generation for migration artifacts is stable when material folders are lexicographically sorted and manifests avoid runtime-specific values (timestamps/random IDs).
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - `cargo fmt --check` should be run before `cargo check/test` in this repo, since small CLI formatting issues are easy to miss and block quality gates.
- Useful context (e.g., "the evaluation panel is in component X")
    - The legacy test corpus currently yields 8 noSCF material cases (`bromoadamantane`, `Copper`, `ferrocene`, `LCO-para`, `LCO-perp`, `NiO`, `UO2`, `Zircon`) for baseline manifest generation.
---
## 2026-02-16 04:19:55 JST - US-004
- Extended the Rust baseline corpus runner to support SCF generation via `cargo run -- baseline scf` (also `withscf` aliases), while keeping deterministic ordering, hashing, and manifest naming.
- Generated versioned SCF artifacts under `docs/migration/baselines/withSCF/v1/` for the same 8 reference materials used by noSCF baselines.
- Added SCF regeneration documentation with command usage and environment prerequisites in `docs/migration/scf-baseline-corpus.md`.
- Files changed: `src/baseline.rs`, `src/main.rs`, `docs/migration/scf-baseline-corpus.md`, `docs/migration/baselines/withSCF/v1/index.json`, `docs/migration/baselines/withSCF/v1/001-bromoadamantane-withscf.json`, `docs/migration/baselines/withSCF/v1/002-copper-withscf.json`, `docs/migration/baselines/withSCF/v1/003-ferrocene-withscf.json`, `docs/migration/baselines/withSCF/v1/004-lco-para-withscf.json`, `docs/migration/baselines/withSCF/v1/005-lco-perp-withscf.json`, `docs/migration/baselines/withSCF/v1/006-nio-withscf.json`, `docs/migration/baselines/withSCF/v1/007-uo2-withscf.json`, `docs/migration/baselines/withSCF/v1/008-zircon-withscf.json`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Baseline generation logic is easiest to keep consistent by routing both noSCF/withSCF through the same manifest pipeline and only varying the variant metadata/path suffixes.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - SCF corpus generation should validate material-set parity with noSCF before writing artifacts, otherwise index-level parity gates can silently drift.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Current corpus coverage is symmetric at 8 materials for both noSCF and withSCF, and SCF manifests are emitted as `NNN-<slug>-withscf.json`.
---
## 2026-02-16 04:23:26 JST - US-005
- Scaffolded a Cargo workspace by adding `crates/feff85exafs-core` and `crates/feff85exafs-errors`, and wiring the root crate as the CLI package that depends on both workspace crates.
- Moved baseline generation engine code into `feff85exafs-core` and introduced a shared `FeffError` type in `feff85exafs-errors` used by both core APIs and CLI argument handling.
- Files changed: `Cargo.toml`, `Cargo.lock`, `src/main.rs`, `src/lib.rs` (deleted), `src/baseline.rs` (moved to core crate), `crates/feff85exafs-core/Cargo.toml`, `crates/feff85exafs-core/src/lib.rs`, `crates/feff85exafs-core/src/baseline.rs`, `crates/feff85exafs-errors/Cargo.toml`, `crates/feff85exafs-errors/src/lib.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Keep CLI-focused UX (argument parsing/output) in the root crate and put reusable execution logic into `crates/feff85exafs-core` so later API stories can build on the same core code.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - When switching a module from `io::Result` to shared error types, explicit `Err(io::Error::other(...).into())` conversions are required in branches that construct errors directly.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Existing `cargo run -- baseline ...` commands continue to work because the root package remains a concrete crate even after enabling workspace members.
---
## 2026-02-16 04:27:21 JST - US-006
- Implemented shared domain model types in `feff85exafs-core`: `RunConfig`, `ParsedInputCards`, and `OutputMetadata` with supporting enums/structs.
- Added serde serialization/deserialization derives and explicit `validate()` methods for each domain model.
- Extended `feff85exafs-errors` with `ValidationIssue`, `ValidationErrors`, and `FeffError::Validation` to report structured validation failures.
- Added unit tests for validation success/failure scenarios and serde round-trips for all shared domain types.
- Files changed: `crates/feff85exafs-core/src/lib.rs`, `crates/feff85exafs-core/src/domain.rs`, `crates/feff85exafs-errors/src/lib.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Use `ValidationErrors` as an accumulator and return a single `FeffError::Validation` from `validate()` so callers get all field failures in one pass.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - `OutputMetadata` validation should enforce unique `PipelineStage` entries; otherwise repeated stage metadata can silently hide orchestration issues.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Domain enums (`RunMode`, `ScfStrategy`, `PipelineStage`) are serde-ready and intended to be reused by upcoming CLI/API mode-selection and orchestration stories.
---
## 2026-02-16 04:31:16 JST - US-007
- Added mode selection plumbing by introducing a reusable core mode API (`parse_run_mode`, `parse_run_mode_or_default`) and wiring CLI support for `--mode <legacy|modern>` with a default of `modern`.
- Invalid mode values now return structured `FeffError::Validation` issues keyed to the `mode` field.
- Added unit coverage for both core mode parsing and CLI mode argument parsing.
- Files changed: `crates/feff85exafs-core/src/lib.rs`, `crates/feff85exafs-core/src/mode.rs`, `src/main.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Parse user-facing enum flags in core-library helpers and reuse them from CLI so mode semantics stay identical between API and command execution.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - Keep filesystem-dependent execution separate from argument parsing; parsing can then be tested without creating corpus fixtures.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Current `baseline` command only uses mode selection as plumbing for upcoming orchestration stories and does not change manifest generation behavior by mode.
---
## 2026-02-16 04:36:31 JST - US-008
- Implemented legacy orchestration behavior in the core library with historical stage ordering (`rdinp -> pot -> xsph -> pathfinder -> genfmt -> ff2x`) and wired CLI legacy runs to surface that order.
- Added legacy baseline filename contract validation for `--mode legacy`, requiring canonical legacy outputs (`feff.inp`, `files.dat`, `paths.dat`, `xmu.dat`, `chi.dat`, `f85e.log`, and `feffNNNN.dat`) before manifest generation succeeds.
- Added an integration test that runs the existing `feff85exafs/bin/f85e` automation path unchanged against mocked module executables and verifies historical stage order execution.
- Files changed: `crates/feff85exafs-core/src/legacy.rs`, `crates/feff85exafs-core/src/lib.rs`, `crates/feff85exafs-core/src/baseline.rs`, `src/main.rs`, `tests/legacy_automation_path.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Legacy compatibility behavior is easiest to keep consistent by centralizing stage order + filename rules in shared core helpers and reusing them from the CLI path.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - The legacy `f85e` script infers the module root from a strict `bin/f85e -> src/*` path layout; integration tests must mirror that layout exactly.
  - Useful context (e.g., "the evaluation panel is in component X")
    - A lightweight mocked `src/{RDINP,POT,XSPH,PATH,GENFMT,FF2X}` tree is sufficient to test unchanged legacy automation behavior without building Fortran binaries.
---
## 2026-02-16 04:41:43 JST - US-009
- Added a modern typed execution API in `feff85exafs-core` by introducing `api::run(RunRequest) -> Result<RunSuccess>` with structured request/operation/result models for baseline execution.
- Refactored the CLI baseline path to call the shared core API entrypoint so command execution and library execution share identical behavior.
- Added compile-checked rustdoc examples for the modern API entrypoint (success and structured validation error flows), plus unit tests for structured success and validation failures.
- Files changed: `crates/feff85exafs-core/src/api.rs`, `crates/feff85exafs-core/src/lib.rs`, `src/main.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Keep new execution capabilities behind `RunOperation` variants in `api.rs` and route CLI handlers through that entrypoint instead of duplicating orchestration logic.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - Unit tests in workspace crates should resolve corpus fixture paths from `env!(\"CARGO_MANIFEST_DIR\")` to avoid brittle relative-path failures when test binaries run from crate directories.
  - Useful context (e.g., "the evaluation panel is in component X")
    - `cargo test --workspace` now includes doctests for `api::run`, so rustdoc code snippets act as compile gates for API documentation.
---
## 2026-02-16 04:45:21 JST - US-010
- Added modern API config-source support in `api.rs` with `RunConfigInput`, `run_with_config(...)`, and `run_from_file(...)` so callers can execute from in-memory requests or file-based JSON configs.
- Kept `api::run(RunRequest)` as the single execution path and refactored shared operation execution behind an internal helper to avoid behavior drift between config sources.
- Added unit tests covering both config paths (in-memory and file-based) plus config-path validation errors.
- Files changed: `crates/feff85exafs-core/src/api.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Add new API input modes as thin adapters that resolve into `RunRequest` and then call `api::run` so business logic remains centralized.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - File-based config support expects JSON shaped like `RunRequest`; parse failures currently surface as `FeffError::InvalidArgument`, while missing/blank path is reported as `FeffError::Validation` on `config.path`.
  - Useful context (e.g., "the evaluation panel is in component X")
    - `api::run_from_file(...)` is now available for integrations that still produce config files, while direct callers can use `api::run_with_config(RunConfigInput::InMemory { ... })`.
---
## 2026-02-16 04:50:57 JST - US-011
- Implemented a new RDINP parser module in `feff85exafs-core` with `parse_rdinp(...)` / `parse_rdinp_str(...)` that parses the Phase 1 corpus card set (`TITLE`, `EDGE`, `S02`, `CONTROL`, `PRINT`, `EXCHANGE`, optional `SCF`, `RPATH`, `EXAFS`, optional `POLARIZATION`, optional `ELLIPTICITY`, `POTENTIALS`, `ATOMS`, optional `END`).
- Added typed validation errors (`FeffError::Validation`) for unsupported cards/values, malformed numerics, malformed section rows, and missing required cards, including line-indexed field paths.
- Added parser test coverage for all 16 baseline `feff.inp` fixtures across noSCF/withSCF plus targeted failure tests for unsupported cards, unsupported edge values, malformed numerics, and missing required cards.
- Files changed: `crates/feff85exafs-core/src/lib.rs`, `crates/feff85exafs-core/src/rdinp.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Treat section rows under `POTENTIALS`/`ATOMS` as first-class parsed records (`POTENTIAL`/`ATOM`) so structural and value validation can run uniformly with top-level cards.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - Some corpus fixtures intentionally omit `END`; parser validation should not require it, but must still require non-empty `POTENTIALS` and `ATOMS` sections.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Current Phase 1 baseline corpus contains 16 `feff.inp` fixtures (8 materials x 2 variants), and all parse successfully with the new RDINP implementation.
---
## 2026-02-16 04:54:31 JST - US-012
- Added RDINP parity test coverage that compares Rust parser output cards against a legacy-style card stream reconstructed from each core baseline `feff.inp` fixture (noSCF + withSCF).
- Defined and enforced parity tolerance rules in tests: exact card order/count, relative numeric tolerance (`1e-9` scaled by value magnitude), and case-insensitive text-token matching.
- Files changed: `crates/feff85exafs-core/src/rdinp.rs`, `scripts/ralph/prd.json`, `scripts/ralph/progress.txt`.
- **Learnings for future iterations:**
  - Patterns discovered (e.g., "this codebase uses X for Y")
    - Reconstructing legacy parity expectations from raw fixture token streams keeps RDINP parity tests deterministic without needing separate snapshot fixtures.
  - Gotchas encountered (e.g., "don't forget to update Z when changing W")
    - Parity helpers must preserve section context (`POTENTIALS` vs `ATOMS`) when converting unlabeled data rows into `POTENTIAL`/`ATOM` records, or card-stream alignment fails.
  - Useful context (e.g., "the evaluation panel is in component X")
    - Current parity test exercises all 16 core corpus inputs and emits index-specific mismatch messages (`card[i]`, `value[j]`) for quick regression triage.
---
